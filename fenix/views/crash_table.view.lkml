
# *Do not manually modify this file*
#
# This file has been generated via https://github.com/mozilla/lookml-generator
# You can extend this view in the looker-spoke-default project (https://github.com/mozilla/looker-spoke-default)

view: crash_table {
  dimension: additional_properties {
    sql: ${TABLE}.additional_properties ;;
    hidden: yes
    description: "A JSON string containing any payload properties not present in the schema"
  }

  dimension: app_version_major {
    sql: ${TABLE}.app_version_major ;;
    type: number
    suggest_persist_for: "24 hours"
  }

  dimension: app_version_minor {
    sql: ${TABLE}.app_version_minor ;;
    type: number
    suggest_persist_for: "24 hours"
  }

  dimension: app_version_patch {
    sql: ${TABLE}.app_version_patch ;;
    type: number
    suggest_persist_for: "24 hours"
  }

  dimension: client_info__android_sdk_version {
    sql: ${TABLE}.client_info.android_sdk_version ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Client Info"
    group_item_label: "Android SDK Version"
    description: "The optional Android specific SDK version of the software running on this hardware device."
  }

  dimension: client_info__app_build {
    sql: ${TABLE}.client_info.app_build ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Client Info"
    group_item_label: "App Build"
    description: "The build identifier generated by the CI system (e.g. \"1234/A\"). For language bindings that provide automatic detection for this value, (e.g. Android/Kotlin), in the unlikely event that the build identifier can not be retrieved from the OS, it is set to \"inaccessible\". For other language bindings, if the value was not provided through configuration, this metric gets set to `Unknown`."
  }

  dimension: client_info__app_channel {
    sql: ${TABLE}.client_info.app_channel ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Client Info"
    group_item_label: "App Channel"
    description: "The channel the application is being distributed on."
  }

  dimension: client_info__app_display_version {
    sql: ${TABLE}.client_info.app_display_version ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Client Info"
    group_item_label: "App Display Version"
    description: "The user visible version string (e.g. \"1.0.3\").  In the unlikely event that the display version can not be retrieved, it is set to \"inaccessible\"."
  }

  dimension: client_info__architecture {
    sql: ${TABLE}.client_info.architecture ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Client Info"
    group_item_label: "Architecture"
    description: "The architecture of the device, (e.g. \"arm\", \"x86\")."
  }

  dimension: client_info__attribution__campaign {
    sql: ${TABLE}.client_info.attribution.campaign ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Client Info: Attribution"
    group_item_label: "Campaign"
    description: "The attribution campaign (e.g. 'mozilla-org')."
  }

  dimension: client_info__attribution__content {
    sql: ${TABLE}.client_info.attribution.content ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Client Info: Attribution"
    group_item_label: "Content"
    description: "The attribution content (e.g. 'firefoxview')."
  }

  dimension: client_info__attribution__ext {
    sql: ${TABLE}.client_info.attribution.ext ;;
    hidden: yes
  }

  dimension: client_info__attribution__medium {
    sql: ${TABLE}.client_info.attribution.medium ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Client Info: Attribution"
    group_item_label: "Medium"
    description: "The attribution medium (e.g. 'organic' for a search engine)."
  }

  dimension: client_info__attribution__source {
    sql: ${TABLE}.client_info.attribution.source ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Client Info: Attribution"
    group_item_label: "Source"
    description: "The attribution source (e.g. 'google-play')."
  }

  dimension: client_info__attribution__term {
    sql: ${TABLE}.client_info.attribution.term ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Client Info: Attribution"
    group_item_label: "Term"
    description: "The attribution term (e.g. 'browser with developer tools for android')."
  }

  dimension: client_info__build_date {
    sql: ${TABLE}.client_info.build_date ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Client Info"
    group_item_label: "Build Date"
    description: "The date & time the application was built"
  }

  dimension: client_info__client_id {
    sql: ${TABLE}.client_info.client_id ;;
    hidden: yes
    description: "A UUID uniquely identifying the client."
  }

  dimension: client_info__device_manufacturer {
    sql: ${TABLE}.client_info.device_manufacturer ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Client Info"
    group_item_label: "Device Manufacturer"
    description: "The manufacturer of the device the application is running on. Not set if the device manufacturer can't be determined (e.g. on Desktop)."
  }

  dimension: client_info__device_model {
    sql: ${TABLE}.client_info.device_model ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Client Info"
    group_item_label: "Device Model"
    description: "The model of the device the application is running on. On Android, this is Build.MODEL, the user-visible marketing name, like \"Pixel 2 XL\". Not set if the device model can't be determined (e.g. on Desktop)."
  }

  dimension: client_info__distribution__ext {
    sql: ${TABLE}.client_info.distribution.ext ;;
    hidden: yes
  }

  dimension: client_info__distribution__name {
    sql: ${TABLE}.client_info.distribution.name ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Client Info: Distribution"
    group_item_label: "Name"
    description: "The distribution name (e.g. 'MozillaOnline')."
  }

  dimension: client_info__first_run_date {
    sql: ${TABLE}.client_info.first_run_date ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Client Info"
    group_item_label: "First Run Date"
    description: "The date of the first run of the application."
  }

  dimension: client_info__locale {
    sql: ${TABLE}.client_info.locale ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Client Info"
    group_item_label: "Locale"
    description: "The locale of the application during initialization (e.g. \"es-ES\"). If the locale can't be determined on the system, the value is [\"und\"](https://unicode.org/reports/tr35/#Unknown_or_Invalid_Identifiers), to indicate \"undetermined\"."
  }

  dimension: client_info__os {
    sql: ${TABLE}.client_info.os ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Client Info"
    group_item_label: "OS"
    description: "The name of the operating system. Possible values: Android, iOS, Linux, Darwin, Windows, FreeBSD, NetBSD, OpenBSD, Solaris, unknown"
  }

  dimension: client_info__os_version {
    sql: ${TABLE}.client_info.os_version ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Client Info"
    group_item_label: "OS Version"
    description: "The user-visible version of the operating system (e.g. \"1.2.3\"). If the version detection fails, this metric gets set to `Unknown`."
  }

  dimension: client_info__session_count {
    sql: ${TABLE}.client_info.session_count ;;
    type: number
    suggest_persist_for: "24 hours"
    group_label: "Client Info"
    group_item_label: "Session Count"
    description: "An optional running counter of the number of sessions for a client."
  }

  dimension: client_info__session_id {
    sql: ${TABLE}.client_info.session_id ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Client Info"
    group_item_label: "Session ID"
    description: "An optional UUID uniquely identifying the client's current session."
  }

  dimension: client_info__telemetry_sdk_build {
    sql: ${TABLE}.client_info.telemetry_sdk_build ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Client Info"
    group_item_label: "Telemetry SDK Build"
    description: "The version of the Glean SDK"
  }

  dimension: client_info__windows_build_number {
    sql: ${TABLE}.client_info.windows_build_number ;;
    type: number
    suggest_persist_for: "24 hours"
    group_label: "Client Info"
    group_item_label: "Windows Build Number"
    description: "The optional Windows build number, reported by Windows (e.g. 22000) and not set for other platforms"
  }

  dimension: document_id {
    sql: ${TABLE}.document_id ;;
    hidden: yes
    description: "The document ID specified in the URI when the client sent this message"
  }

  dimension: events {
    sql: ${TABLE}.events ;;
    hidden: yes
  }

  dimension: is_bot_generated {
    sql: ${TABLE}.is_bot_generated ;;
    type: yesno
    suggest_persist_for: "24 hours"
  }

  dimension: metadata__geo__city {
    sql: ${TABLE}.metadata.geo.city ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metadata: Geo"
    group_item_label: "City"
  }

  dimension: metadata__geo__country {
    sql: ${TABLE}.metadata.geo.country ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metadata: Geo"
    group_item_label: "Country"
    map_layer_name: countries
    description: "An ISO 3166-1 alpha-2 country code"
  }

  dimension: metadata__geo__db_version {
    sql: ${TABLE}.metadata.geo.db_version ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metadata: Geo"
    group_item_label: "DB Version"
    description: "The specific geo database version used for this lookup"
  }

  dimension: metadata__geo__subdivision1 {
    sql: ${TABLE}.metadata.geo.subdivision1 ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metadata: Geo"
    group_item_label: "Subdivision1"
    description: "First major country subdivision, typically a state, province, or county"
  }

  dimension: metadata__geo__subdivision2 {
    sql: ${TABLE}.metadata.geo.subdivision2 ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metadata: Geo"
    group_item_label: "Subdivision2"
    description: "Second major country subdivision; not applicable for most countries"
  }

  dimension: metadata__header__date {
    sql: ${TABLE}.metadata.header.date ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metadata: Header"
    group_item_label: "Date"
    description: "Date HTTP header"
  }

  dimension: metadata__header__dnt {
    sql: ${TABLE}.metadata.header.dnt ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metadata: Header"
    group_item_label: "DNT"
    description: "DNT (Do Not Track) HTTP header"
  }

  dimension: metadata__header__parsed_x_lb_tags__tls_cipher_hex {
    sql: ${TABLE}.metadata.header.parsed_x_lb_tags.tls_cipher_hex ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metadata: Header: Parsed X LB Tags"
    group_item_label: "TLS Cipher Hex"
  }

  dimension: metadata__header__parsed_x_lb_tags__tls_version {
    sql: ${TABLE}.metadata.header.parsed_x_lb_tags.tls_version ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metadata: Header: Parsed X LB Tags"
    group_item_label: "TLS Version"
  }

  dimension: metadata__header__parsed_x_source_tags {
    sql: ${TABLE}.metadata.header.parsed_x_source_tags ;;
    hidden: yes
  }

  dimension: metadata__header__x_debug_id {
    sql: ${TABLE}.metadata.header.x_debug_id ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metadata: Header"
    group_item_label: "X Debug ID"
    description: "X-Debug-Id HTTP header"
  }

  dimension: metadata__header__x_foxsec_ip_reputation {
    sql: ${TABLE}.metadata.header.x_foxsec_ip_reputation ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metadata: Header"
    group_item_label: "X Foxsec IP Reputation"
    description: "X-Foxsec-IP-Reputation header"
  }

  dimension: metadata__header__x_lb_tags {
    sql: ${TABLE}.metadata.header.x_lb_tags ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metadata: Header"
    group_item_label: "X LB Tags"
    description: "X-LB-Tags HTTP header"
  }

  dimension: metadata__header__x_pingsender_version {
    sql: ${TABLE}.metadata.header.x_pingsender_version ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metadata: Header"
    group_item_label: "X Pingsender Version"
    description: "X-PingSender-Version HTTP header"
  }

  dimension: metadata__header__x_source_tags {
    sql: ${TABLE}.metadata.header.x_source_tags ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metadata: Header"
    group_item_label: "X Source Tags"
    description: "X-Source-Tags HTTP header"
  }

  dimension: metadata__header__x_telemetry_agent {
    sql: ${TABLE}.metadata.header.x_telemetry_agent ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metadata: Header"
    group_item_label: "X Telemetry Agent"
    description: "X-Telemetry-Agent HTTP header"
  }

  dimension: metadata__isp__db_version {
    sql: ${TABLE}.metadata.isp.db_version ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metadata: ISP"
    group_item_label: "DB Version"
    description: "The specific geo ISP database version used for this lookup"
  }

  dimension: metadata__isp__name {
    sql: ${TABLE}.metadata.isp.name ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metadata: ISP"
    group_item_label: "Name"
    description: "The name of the ISP associated with the client's IP address"
  }

  dimension: metadata__isp__organization {
    sql: ${TABLE}.metadata.isp.organization ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metadata: ISP"
    group_item_label: "Organization"
    description: "The name of a specific business entity associated with the client's IP address when available; otherwise the ISP name"
  }

  dimension: metadata__user_agent__browser {
    sql: ${TABLE}.metadata.user_agent.browser ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metadata: User Agent"
    group_item_label: "Browser"
  }

  dimension: metadata__user_agent__os {
    sql: ${TABLE}.metadata.user_agent.os ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metadata: User Agent"
    group_item_label: "OS"
  }

  dimension: metadata__user_agent__version {
    sql: ${TABLE}.metadata.user_agent.version ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metadata: User Agent"
    group_item_label: "Version"
  }

  dimension: metrics__boolean__crash_dom_fission_enabled {
    sql: ${TABLE}.metrics.boolean.crash_dom_fission_enabled ;;
    type: yesno
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Boolean"
    group_item_label: "Crash DOM Fission Enabled"
    description: "Set to 1 when DOM fission is enabled, and subframes are potentially loaded in a separate process."
  }

  dimension: metrics__boolean__crash_is_garbage_collecting {
    sql: ${TABLE}.metrics.boolean.crash_is_garbage_collecting ;;
    type: yesno
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Boolean"
    group_item_label: "Crash Is Garbage Collecting"
    description: "If true then the JavaScript garbage collector was running when the crash occurred."
  }

  dimension: metrics__boolean__crash_startup {
    sql: ${TABLE}.metrics.boolean.crash_startup ;;
    type: yesno
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Boolean"
    group_item_label: "Crash Startup"
    description: "If set to 1 then this crash occurred during startup."
  }

  dimension: metrics__boolean__crash_windows_error_reporting {
    sql: ${TABLE}.metrics.boolean.crash_windows_error_reporting ;;
    type: yesno
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Boolean"
    group_item_label: "Crash Windows Error Reporting"
    description: "Set to 1 if this crash was intercepted via the Windows Error Reporting runtime exception module."
  }

  dimension: metrics__boolean__dll_blocklist_init_failed {
    sql: ${TABLE}.metrics.boolean.dll_blocklist_init_failed ;;
    type: yesno
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Boolean"
    group_item_label: "Dll Blocklist Init Failed"
    description: "Set to 1 if the DLL blocklist could not be initialized."
  }

  dimension: metrics__boolean__dll_blocklist_user32_loaded_before {
    sql: ${TABLE}.metrics.boolean.dll_blocklist_user32_loaded_before ;;
    type: yesno
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Boolean"
    group_item_label: "Dll Blocklist User32 Loaded Before"
    description: "Set to 1 if user32.dll was loaded before we could install the DLL blocklist."
  }

  dimension: metrics__boolean__environment_headless_mode {
    sql: ${TABLE}.metrics.boolean.environment_headless_mode ;;
    type: yesno
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Boolean"
    group_item_label: "Environment Headless Mode"
    description: "True if the app was invoked in headless mode via `--headless ...` or `--backgroundtask ...`, false otherwise."
  }

  dimension: metrics__datetime__raw_crash_time {
    sql: ${TABLE}.metrics.datetime.raw_crash_time ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Datetime"
    group_item_label: "Raw Crash Time"
  }

  dimension: metrics__labeled_counter__glean_error_invalid_label {
    sql: ${TABLE}.metrics.labeled_counter.glean_error_invalid_label ;;
    hidden: yes
    description: "Counts the number of times a metric was set with an invalid label.
The labels are the `category.name` identifier of the metric.
"
  }

  dimension: metrics__labeled_counter__glean_error_invalid_overflow {
    sql: ${TABLE}.metrics.labeled_counter.glean_error_invalid_overflow ;;
    hidden: yes
    description: "Counts the number of times a metric was set a value that overflowed.
The labels are the `category.name` identifier of the metric.
"
  }

  dimension: metrics__labeled_counter__glean_error_invalid_state {
    sql: ${TABLE}.metrics.labeled_counter.glean_error_invalid_state ;;
    hidden: yes
    description: "Counts the number of times a timing metric was used incorrectly.
The labels are the `category.name` identifier of the metric.
"
  }

  dimension: metrics__labeled_counter__glean_error_invalid_value {
    sql: ${TABLE}.metrics.labeled_counter.glean_error_invalid_value ;;
    hidden: yes
    description: "Counts the number of times a metric was set to an invalid value.
The labels are the `category.name` identifier of the metric.
"
  }

  dimension: metrics__object__crash_async_shutdown_timeout {
    sql: ${TABLE}.metrics.object.crash_async_shutdown_timeout ;;
    hidden: yes
    description: "This annotation is present if a shutdown blocker was not released in time and the browser was crashed instead of waiting for shutdown to finish. The condition that caused the hang is contained in the annotation."
  }

  dimension: metrics__object__crash_breadcrumbs {
    sql: ${TABLE}.metrics.object.crash_breadcrumbs ;;
    hidden: yes
    description: "Crash breadcrumb information.
"
  }

  dimension: metrics__object__crash_java_exception {
    sql: ${TABLE}.metrics.object.crash_java_exception ;;
    hidden: yes
    description: "JSON structured Java stack trace, only present on Firefox for Android if we encounter an uncaught Java exception."
  }

  dimension: metrics__object__crash_quota_manager_shutdown_timeout {
    sql: ${TABLE}.metrics.object.crash_quota_manager_shutdown_timeout ;;
    hidden: yes
    description: "This annotation is present if the quota manager shutdown (resp. the shutdown of the quota manager clients) was not finished in time and the browser was crashed instead of waiting for the shutdown to finish. The status of objects which were blocking completion of the shutdown when reaching the timeout is contained in the annotation.
In the case of IndexedDB, objects are divided into three groups: FactoryOperations, LiveDatabases and DatabaseMaintenances.
In the case of LocalStorage, objects are divided into three groups: PrepareDatastoreOperations, Datastores and LiveDatabases.
In the case of Cache API, objects are in one group only: Managers.
Each group is reported separately and contains the number of objects in the group and the status of individual objects in the group (duplicate entries are removed): \"GroupName: N (objectStatus1, objectStatus2, ...)\" where N is the number of objects in the group.
The status of individual objects is constructed by taking selected object properties. Properties which contain"
  }

  dimension: metrics__object__crash_stack_traces {
    sql: ${TABLE}.metrics.object.crash_stack_traces ;;
    hidden: yes
    description: "Stack traces extracted from the crash minidump, if available. These are sent in pings, however they are extracted and transformed into a different format. The field in the extra file is meant only for client use."
  }

  dimension: metrics__quantity__crash_event_loop_nesting_level {
    sql: ${TABLE}.metrics.quantity.crash_event_loop_nesting_level ;;
    type: number
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Quantity"
    group_item_label: "Crash Event Loop Nesting Level"
    description: "Present only if higher than 0, indicates that we're running in a nested event loop and indicates the nesting level."
  }

  dimension: metrics__quantity__crash_gpu_process_launch {
    sql: ${TABLE}.metrics.quantity.crash_gpu_process_launch ;;
    type: number
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Quantity"
    group_item_label: "Crash GPU Process Launch"
    description: "Number of times the GPU process was launched."
  }

  dimension: metrics__quantity__memory_available_commit {
    sql: ${TABLE}.metrics.quantity.memory_available_commit ;;
    type: number
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Quantity"
    group_item_label: "Memory Available Commit"
    description: "Available commit-space in bytes. - Under Windows, computed from the PERFORMANCE_INFORMATION structure by substracting
  the CommitTotal field from the CommitLimit field.
- Under Linux, computed from /proc/meminfo's CommitLimit - Committed_AS. Note that
  the kernel is not guaranteed to enforce that CommittedLimit >= Committed_AS. If
  Committed_AS > CommittedLimit, this value is set to 0.
- Not available on other platforms."
  }

  dimension: metrics__quantity__memory_available_physical {
    sql: ${TABLE}.metrics.quantity.memory_available_physical ;;
    type: number
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Quantity"
    group_item_label: "Memory Available Physical"
    description: "Amount of free physical memory in bytes. - Under Windows, populated with the contents of the MEMORYSTATUSEX's structure ullAvailPhys field. - Under macOS, populated with vm_statistics64_data_t::free_count. - Under Linux, populated with /proc/meminfo's MemFree. - Not available on other platforms."
  }

  dimension: metrics__quantity__memory_available_swap {
    sql: ${TABLE}.metrics.quantity.memory_available_swap ;;
    type: number
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Quantity"
    group_item_label: "Memory Available Swap"
    description: "Amount of free swap space in bytes. - Under macOS, populated with the contents of
  sysctl \"vm.swapusage\" :: xsu_avail.
- Under Linux, populated with /proc/meminfo's SwapFree. - Not available on other platforms."
  }

  dimension: metrics__quantity__memory_available_virtual {
    sql: ${TABLE}.metrics.quantity.memory_available_virtual ;;
    type: number
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Quantity"
    group_item_label: "Memory Available Virtual"
    description: "Amount of free virtual memory in bytes - Under Windows, populated with the contents of the MEMORYSTATUSEX's structure ullAvailVirtual field. - Under Linux, populated with /proc/meminfo's MemAvailable. - Not available on other platforms. - For macOS, see AvailableSwapMemory, AvailablePhysicalMemory and PurgeablePhysicalMemory."
  }

  dimension: metrics__quantity__memory_low_physical {
    sql: ${TABLE}.metrics.quantity.memory_low_physical ;;
    type: number
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Quantity"
    group_item_label: "Memory Low Physical"
    description: "Number of times the available memory tracker has detected that free physical memory is running low. This is a Windows-specific annotation."
  }

  dimension: metrics__quantity__memory_oom_allocation_size {
    sql: ${TABLE}.metrics.quantity.memory_oom_allocation_size ;;
    type: number
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Quantity"
    group_item_label: "Memory Oom Allocation Size"
    description: "Size of the allocation that caused an out-of-memory condition."
  }

  dimension: metrics__quantity__memory_purgeable_physical {
    sql: ${TABLE}.metrics.quantity.memory_purgeable_physical ;;
    type: number
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Quantity"
    group_item_label: "Memory Purgeable Physical"
    description: "macOS only. Amount of physical memory currently allocated but which may be deallocated by the system in case of memory pressure. Populated from vm_statistics64_data_t::purgeable_count * vm_page_size."
  }

  dimension: metrics__quantity__memory_system_use_percentage {
    sql: ${TABLE}.metrics.quantity.memory_system_use_percentage ;;
    type: number
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Quantity"
    group_item_label: "Memory System Use Percentage"
    description: "Windows-only, percentage of physical memory in use. This annotation is populated with the contents of the MEMORYSTATUSEX's structure dwMemoryLoad field."
  }

  dimension: metrics__quantity__memory_texture {
    sql: ${TABLE}.metrics.quantity.memory_texture ;;
    type: number
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Quantity"
    group_item_label: "Memory Texture"
    description: "Amount of memory in bytes consumed by textures."
  }

  dimension: metrics__quantity__memory_total_page_file {
    sql: ${TABLE}.metrics.quantity.memory_total_page_file ;;
    type: number
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Quantity"
    group_item_label: "Memory Total Page File"
    description: "Maximum amount of memory that can be committed without extending the swap/page file. - Under Windows, populated with the contents of the PERFORMANCE_INFORMATION's
  structure CommitLimit field.
- Under Linux, populated with /proc/meminfo MemTotal + SwapTotal. The swap file
  typically cannot be extended, so that's a hard limit.
- Not available on other systems."
  }

  dimension: metrics__quantity__memory_total_physical {
    sql: ${TABLE}.metrics.quantity.memory_total_physical ;;
    type: number
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Quantity"
    group_item_label: "Memory Total Physical"
    description: "Amount of physical memory in bytes. - Under Windows, populated with the contents of the MEMORYSTATUSEX's structure ullTotalPhys field. - Under macOS, populated with sysctl \"hw.memsize\". - Under Linux, populated with /proc/meminfo's \"MemTotal\". - Not available on other systems."
  }

  dimension: metrics__quantity__memory_total_virtual {
    sql: ${TABLE}.metrics.quantity.memory_total_virtual ;;
    type: number
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Quantity"
    group_item_label: "Memory Total Virtual"
    description: "Size of the virtual address space. - Under Windows, populated with the contents of the MEMORYSTATUSEX's structure
  ullTotalVirtual field.
- Not available on other platforms."
  }

  dimension: metrics__string__crash_app_build {
    sql: ${TABLE}.metrics.string.crash_app_build ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Crash App Build"
    description: "Product application's build ID."
  }

  dimension: metrics__string__crash_app_channel {
    sql: ${TABLE}.metrics.string.crash_app_channel ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Crash App Channel"
    description: "Application release channel (e.g. default, beta, ...)"
  }

  dimension: metrics__string__crash_app_display_version {
    sql: ${TABLE}.metrics.string.crash_app_display_version ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Crash App Display Version"
    description: "Product version."
  }

  dimension: metrics__string__crash_background_task_name {
    sql: ${TABLE}.metrics.string.crash_background_task_name ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Crash Background Task Name"
    description: "If the app was invoked in background task mode via `--backgroundtask <task name>`, the string \"task name\"."
  }

  dimension: metrics__string__crash_build_id {
    sql: ${TABLE}.metrics.string.crash_build_id ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Crash Build ID"
    description: "Application build ID, the format is YYYYMMDDHHMMSS."
  }

  dimension: metrics__string__crash_cause {
    sql: ${TABLE}.metrics.string.crash_cause ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Crash Cause"
    description: "The cause of the crash. May be one of `os_fault` or `java_exception`.
"
  }

  dimension: metrics__string__crash_crash_type {
    sql: ${TABLE}.metrics.string.crash_crash_type ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Crash Crash Type"
    description: "The type of crash that occurred (Android-only)."
  }

  dimension: metrics__string__crash_font_name {
    sql: ${TABLE}.metrics.string.crash_font_name ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Crash Font Name"
    description: "Set before attempting to load a font to help diagnose crashes during loading."
  }

  dimension: metrics__string__crash_hang {
    sql: ${TABLE}.metrics.string.crash_hang ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Crash Hang"
    description: "Set if the crash was the result of a hang, with a value which describes the type of hang (e.g. \"ui\" or \"shutdown\")."
  }

  dimension: metrics__string__crash_ipc_channel_error {
    sql: ${TABLE}.metrics.string.crash_ipc_channel_error ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Crash Ipc Channel Error"
    description: "Set before a content process crashes because of an IPC channel error. Holds a description of the error."
  }

  dimension: metrics__string__crash_linux_memory_psi {
    sql: ${TABLE}.metrics.string.crash_linux_memory_psi ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Crash Linux Memory Psi"
    description: "Memory PSI (Pressure Stall Information) values from /proc/pressure/memory as comma-separated list: some_avg10,some_avg60,some_avg300,some_total,full_avg10,full_avg60,full_avg300,full_total"
  }

  dimension: metrics__string__crash_main_thread_runnable_name {
    sql: ${TABLE}.metrics.string.crash_main_thread_runnable_name ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Crash Main Thread Runnable Name"
    description: "Name of the currently executing nsIRunnable on the main thread."
  }

  dimension: metrics__string__crash_minidump_sha256_hash {
    sql: ${TABLE}.metrics.string.crash_minidump_sha256_hash ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Crash Minidump Sha256 Hash"
    description: "The SHA256 hash of the associated minidump file, if any.
"
  }

  dimension: metrics__string__crash_minidump_sha_256_hash {
    sql: ${TABLE}.metrics.string.crash_minidump_sha_256_hash ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Crash Minidump Sha 256 Hash"
    description: "The sha256 hash of the minidump file, if available."
  }

  dimension: metrics__string__crash_moz_crash_reason {
    sql: ${TABLE}.metrics.string.crash_moz_crash_reason ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Crash Moz Crash Reason"
    description: "Plaintext description of why Firefox crashed, this is usually set by assertions and the like."
  }

  dimension: metrics__string__crash_process_type {
    sql: ${TABLE}.metrics.string.crash_process_type ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Crash Process Type"
    description: "Type of the process that crashed, the possible values are defined in GeckoProcessTypes.h."
  }

  dimension: metrics__string__crash_product_id {
    sql: ${TABLE}.metrics.string.crash_product_id ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Crash Product ID"
    description: "Application UUID (e.g. ec8030f7-c20a-464f-9b0e-13a3a9e97384)."
  }

  dimension: metrics__string__crash_product_name {
    sql: ${TABLE}.metrics.string.crash_product_name ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Crash Product Name"
    description: "Application name (e.g. Firefox)."
  }

  dimension: metrics__string__crash_profiler_child_shutdown_phase {
    sql: ${TABLE}.metrics.string.crash_profiler_child_shutdown_phase ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Crash Profiler Child Shutdown Phase"
    description: "When a child process shuts down, this describes if the profiler is running, and the point the profiler shutdown sequence has reached."
  }

  dimension: metrics__string__crash_remote_type {
    sql: ${TABLE}.metrics.string.crash_remote_type ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Crash Remote Type"
    description: "Type of the content process, can be set to \"web\", \"file\" or \"extension\"."
  }

  dimension: metrics__string__crash_shutdown_progress {
    sql: ${TABLE}.metrics.string.crash_shutdown_progress ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Crash Shutdown Progress"
    description: "Shutdown step at which the browser crashed, can be set to \"quit-application\", \"profile-change-teardown\", \"profile-before-change\", \"xpcom-will-shutdown\" or \"xpcom-shutdown\"."
  }

  dimension: metrics__string__crash_shutdown_reason {
    sql: ${TABLE}.metrics.string.crash_shutdown_reason ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Crash Shutdown Reason"
    description: "One out of \"Unknown\", \"AppClose\", \"AppRestart\", \"OSForceClose\", \"OSSessionEnd\" or \"OSShutdown\"."
  }

  dimension: metrics__string__crash_windows_file_dialog_error_code {
    sql: ${TABLE}.metrics.string.crash_windows_file_dialog_error_code ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Crash Windows File Dialog Error Code"
    description: "The HRESULT returned from a Win32 system call leading to termination of the file-dialog utility process. MozCrashReason is expected to provide context for the value."
  }

  dimension: metrics__string__glean_client_annotation_experimentation_id {
    sql: ${TABLE}.metrics.string.glean_client_annotation_experimentation_id ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Glean Client Annotation Experimentation ID"
    description: "An experimentation identifier derived and provided by the application
for the purpose of experimentation enrollment.
"
  }

  dimension: metrics__string__memory_js_large_allocation_failure {
    sql: ${TABLE}.metrics.string.memory_js_large_allocation_failure ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Memory Js Large Allocation Failure"
    description: "A large allocation couldn't be satisfied, check the JSOutOfMemory description for the possible values of this annotation."
  }

  dimension: metrics__string__memory_js_out_of_memory {
    sql: ${TABLE}.metrics.string.memory_js_out_of_memory ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Memory Js Out Of Memory"
    description: "A small allocation couldn't be satisfied, the annotation may contain the \"Reporting\", \"Reported\" or \"Recovered\" value. The first one means that we crashed while responding to the OOM condition (possibly while running a memory-pressure observers), the second that we crashed after having tried to free some memory, and the last that the GC had managed to free enough memory to satisfy the allocation."
  }

  dimension: metrics__string__windows_package_family_name {
    sql: ${TABLE}.metrics.string.windows_package_family_name ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: String"
    group_item_label: "Windows Package Family Name"
    description: "If running in a Windows package context, the package family name, per https://docs.microsoft.com/en-us/windows/win32/api/appmodel/nf-appmodel-getcurrentpackagefamilyname.
The package family name is only included when it is likely to have been produced by Mozilla: it starts \"Mozilla.\" or \"MozillaCorporation.\"."
  }

  dimension: metrics__string_list__crash_utility_actors_name {
    sql: ${TABLE}.metrics.string_list.crash_utility_actors_name ;;
    hidden: yes
  }

  dimension: metrics__string_list__dll_blocklist_list {
    sql: ${TABLE}.metrics.string_list.dll_blocklist_list ;;
    hidden: yes
  }

  dimension: metrics__string_list__environment_experimental_features {
    sql: ${TABLE}.metrics.string_list.environment_experimental_features ;;
    hidden: yes
  }

  dimension: metrics__string_list__environment_nimbus_enrollments {
    sql: ${TABLE}.metrics.string_list.environment_nimbus_enrollments ;;
    hidden: yes
  }

  dimension: metrics__string_list__glean_ping_uploader_capabilities {
    sql: ${TABLE}.metrics.string_list.glean_ping_uploader_capabilities ;;
    hidden: yes
  }

  dimension: metrics__timespan__crash_last_interaction_duration__time_unit {
    sql: ${TABLE}.metrics.timespan.crash_last_interaction_duration.time_unit ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Timespan: Crash Last Interaction Duration"
    group_item_label: "Time Unit"
  }

  dimension: metrics__timespan__crash_last_interaction_duration__value {
    sql: ${TABLE}.metrics.timespan.crash_last_interaction_duration.value ;;
    type: number
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Timespan: Crash Last Interaction Duration"
    group_item_label: "Value"
  }

  dimension: metrics__timespan__crash_time_since_last_crash__time_unit {
    sql: ${TABLE}.metrics.timespan.crash_time_since_last_crash.time_unit ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Timespan: Crash Time Since Last Crash"
    group_item_label: "Time Unit"
  }

  dimension: metrics__timespan__crash_time_since_last_crash__value {
    sql: ${TABLE}.metrics.timespan.crash_time_since_last_crash.value ;;
    type: number
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Timespan: Crash Time Since Last Crash"
    group_item_label: "Value"
  }

  dimension: metrics__timespan__crash_uptime__time_unit {
    sql: ${TABLE}.metrics.timespan.crash_uptime.time_unit ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Timespan: Crash Uptime"
    group_item_label: "Time Unit"
  }

  dimension: metrics__timespan__crash_uptime__value {
    sql: ${TABLE}.metrics.timespan.crash_uptime.value ;;
    type: number
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Timespan: Crash Uptime"
    group_item_label: "Value"
  }

  dimension: metrics__timespan__environment_uptime__time_unit {
    sql: ${TABLE}.metrics.timespan.environment_uptime.time_unit ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Timespan: Environment Uptime"
    group_item_label: "Time Unit"
  }

  dimension: metrics__timespan__environment_uptime__value {
    sql: ${TABLE}.metrics.timespan.environment_uptime.value ;;
    type: number
    suggest_persist_for: "24 hours"
    group_label: "Metrics: Timespan: Environment Uptime"
    group_item_label: "Value"
  }

  dimension: normalized_app_id {
    sql: ${TABLE}.normalized_app_id ;;
    type: string
    suggest_persist_for: "24 hours"
    description: "App ID of the channel data was received from"
  }

  dimension: normalized_app_name {
    sql: ${TABLE}.normalized_app_name ;;
    type: string
    suggest_persist_for: "24 hours"
    description: "Set to \"Other\" if this message contained an unrecognized app name"
  }

  dimension: normalized_channel {
    sql: ${TABLE}.normalized_channel ;;
    type: string
    suggest_persist_for: "24 hours"
    description: "Normalized channel name"
  }

  dimension: normalized_country_code {
    sql: ${TABLE}.normalized_country_code ;;
    type: string
    suggest_persist_for: "24 hours"
    description: "An ISO 3166-1 alpha-2 country code"
  }

  dimension: normalized_os {
    sql: ${TABLE}.normalized_os ;;
    type: string
    suggest_persist_for: "24 hours"
    description: "Set to \"Other\" if this message contained an unrecognized OS name"
  }

  dimension: normalized_os_version {
    sql: ${TABLE}.normalized_os_version ;;
    type: string
    suggest_persist_for: "24 hours"
  }

  dimension: ping_info__end_time {
    sql: ${TABLE}.ping_info.end_time ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Ping Info"
    group_item_label: "End Time"
  }

  dimension: ping_info__experiments {
    sql: ${TABLE}.ping_info.experiments ;;
    hidden: yes
  }

  dimension: ping_info__ping_type {
    sql: ${TABLE}.ping_info.ping_type ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Ping Info"
    group_item_label: "Ping Type"
  }

  dimension: ping_info__reason {
    sql: ${TABLE}.ping_info.reason ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Ping Info"
    group_item_label: "Reason"
  }

  dimension: ping_info__seq {
    sql: ${TABLE}.ping_info.seq ;;
    type: number
    suggest_persist_for: "24 hours"
    group_label: "Ping Info"
    group_item_label: "Seq"
  }

  dimension: ping_info__start_time {
    sql: ${TABLE}.ping_info.start_time ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Ping Info"
    group_item_label: "Start Time"
  }

  dimension: sample_id {
    sql: ${TABLE}.sample_id ;;
    type: number
    suggest_persist_for: "24 hours"
    description: "Hashed version of client_id (if present) useful for partitioning; ranges from 0 to 99"
  }

  dimension_group: metadata__header__parsed {
    sql: ${TABLE}.metadata.header.parsed_date ;;
    type: time
    timeframes: [
      raw,
      time,
      date,
      week,
      month,
      quarter,
      year,
    ]
    label: "Metadata: Header: Parsed Date"
  }

  dimension_group: metrics__datetime__crash {
    sql: ${TABLE}.metrics.datetime.crash_time ;;
    type: time
    timeframes: [
      raw,
      time,
      date,
      week,
      month,
      quarter,
      year,
    ]
    label: "Metrics: Datetime: Crash Time"
    description: "Crash time in seconds since the Epoch."
  }

  dimension_group: ping_info__parsed_end {
    sql: ${TABLE}.ping_info.parsed_end_time ;;
    type: time
    timeframes: [
      raw,
      time,
      date,
      week,
      month,
      quarter,
      year,
    ]
    label: "Ping Info: Parsed End Time"
  }

  dimension_group: ping_info__parsed_start {
    sql: ${TABLE}.ping_info.parsed_start_time ;;
    type: time
    timeframes: [
      raw,
      time,
      date,
      week,
      month,
      quarter,
      year,
    ]
    label: "Ping Info: Parsed Start Time"
  }

  dimension_group: submission {
    sql: ${TABLE}.submission_timestamp ;;
    type: time
    timeframes: [
      raw,
      time,
      date,
      week,
      month,
      quarter,
      year,
    ]
    description: "Time when the ingestion edge server accepted this message"
  }

  parameter: channel {
    type: unquoted
    default_value: "mozdata.fenix.crash"

    allowed_value: {
      label: "Release"
      value: "mozdata.fenix.crash"
    }

    allowed_value: {
      label: "Beta"
      value: "mozdata.org_mozilla_firefox_beta.crash"
    }

    allowed_value: {
      label: "Nightly"
      value: "mozdata.org_mozilla_fenix.crash"
    }

    allowed_value: {
      label: "Nightly"
      value: "mozdata.org_mozilla_fenix_nightly.crash"
    }

    allowed_value: {
      label: "Nightly"
      value: "mozdata.org_mozilla_fennec_aurora.crash"
    }
  }

  sql_table_name: `{% parameter channel %}` ;;
}

view: crash_table__events {
  dimension: category {
    sql: ${TABLE}.category ;;
    type: string
    suggest_persist_for: "24 hours"
  }

  dimension: extra {
    sql: ${TABLE}.extra ;;
    hidden: yes
  }

  dimension: name {
    sql: ${TABLE}.name ;;
    type: string
    suggest_persist_for: "24 hours"
  }

  dimension: timestamp {
    sql: ${TABLE}.timestamp ;;
    type: number
    suggest_persist_for: "24 hours"
  }
}

view: crash_table__events__extra {
  dimension: key {
    sql: ${TABLE}.key ;;
    type: string
    suggest_persist_for: "24 hours"
  }

  dimension: value {
    sql: ${TABLE}.value ;;
    type: string
    suggest_persist_for: "24 hours"
  }
}

view: crash_table__ping_info__experiments {
  dimension: key {
    sql: ${TABLE}.key ;;
    type: string
    suggest_persist_for: "24 hours"
  }

  dimension: value__branch {
    sql: ${TABLE}.value.branch ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Value"
    group_item_label: "Branch"
  }

  dimension: value__extra__enrollment_id {
    sql: ${TABLE}.value.extra.enrollment_id ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Value: Extra"
    group_item_label: "Enrollment ID"
  }

  dimension: value__extra__type {
    sql: ${TABLE}.value.extra.type ;;
    type: string
    suggest_persist_for: "24 hours"
    group_label: "Value: Extra"
    group_item_label: "Type"
  }
}